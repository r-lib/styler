<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Manipulating the nested parse table • styler</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha256-nAmazAk6vS34Xqo0BSrTb+abbtFlgsFK7NKSi6o7Y78=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/v4-shims.min.css" integrity="sha256-6qHlizsOWFskGlwVOKuns+D1nB6ssZrHQrNj1wGplHc=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/headroom.min.js" integrity="sha256-DJFC1kqIhelURkuza0AvYal5RxMtpzLjFhsnVIeuk+U=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../../pkgdown.css" rel="stylesheet">
<script src="../../pkgdown.js"></script><meta property="og:title" content="Manipulating the nested parse table">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<meta name="robots" content="noindex">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../../index.html">styler</a>
        <span class="version label label-danger" data-toggle="tooltip" data-placement="bottom" title="In-development version">1.3.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/caching.html">Caching</a>
    </li>
    <li>
      <a href="../../articles/customizing_styler.html">Customizing styler</a>
    </li>
    <li>
      <a href="../../articles/detect-alignment.html">Alignment detection</a>
    </li>
    <li>
      <a href="../../articles/gsoc_proposal/data_structures.html">Data Structures</a>
    </li>
    <li>
      <a href="../../articles/gsoc_proposal/manipulating_nested_parse_data.html">Manipulating the nested parse table</a>
    </li>
    <li>
      <a href="../../articles/introducing_styler.html">An introduction to styler</a>
    </li>
    <li>
      <a href="../../articles/performance_improvements.html">Performance Improvements</a>
    </li>
  </ul>
</li>
<li>
  <a href="../../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/r-lib/styler">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Manipulating the nested parse table</h1>
                        <h4 class="author">Lorenz Walthert</h4>
            
            <h4 class="date">2020-02-11</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/r-lib/styler/blob/master/vignettes/gsoc_proposal/manipulating_nested_parse_data.Rmd"><code>vignettes/gsoc_proposal/manipulating_nested_parse_data.Rmd</code></a></small>
      <div class="hidden name"><code>manipulating_nested_parse_data.Rmd</code></div>

    </div>

    
    
<blockquote>
<p>This vignette is partly outdated since nested structure was implemented completely. In particular, the serialization is now done differently.</p>
</blockquote>
<pre><code><a href="https://rdrr.io/r/base/library.html">library("dplyr")
library("purrr")
pkgload::load_all()</a></code></pre>
<p>This vignette builds on the vignette “Data Structures” and discusses how to go forward with the nested structure of the parse data. In order to compute the white space information in a nested data structure, we use a <a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor approach</a> to separate the algorithm (computing white space information and later apply transformations) from the object (nested data structure). The function <code>create_filler()</code> (name depreciated, now called <code><a href="../../reference/default_style_guide_attributes.html">default_style_guide_attributes()</a></code>) can then be used to compute current white space information on every level of nesting within the nested parse data if applied in combination with the visitor. In the sequel, a parse table at one level of nesting will be denoted with the term <em>nest</em>, which always represents a complete expression. Our visiting functions <code><a href="../../reference/visit.html">pre_visit()</a></code> and <code><a href="../../reference/visit.html">post_visit()</a></code> take an object to operate on and a list of functions. Concretely, the object is the nested parse table. Each function is applied at each level of nesting nesting before the next level of nesting is entered. You can find out more about the visitor on the help file for <code>visit</code> (note that this function is not exported by styler). pre_visit</p>
<pre><code>## function(pd_nested, funs) {
##   if (is.null(pd_nested)) return()
##   pd_transformed &lt;- visit_one(pd_nested, funs)
## 
##   pd_transformed$child &lt;- map(pd_transformed$child, pre_visit, funs = funs)
##   pd_transformed
## }
## &lt;environment: namespace:styler&gt;

visit_one

## function(pd_flat, funs) {
##   reduce(funs, function(x, fun) fun(x),
##          .init = pd_flat)
## }
## &lt;environment: namespace:styler&gt;</code></pre>
<p>This comes with two advantages.</p>
<ul>
<li><p>We go through the whole structure only as many times as we call the visitor (instead of every *_nested() function going through it once, which is more efficient in terms of speed.</p></li>
<li>We don’t need a *_nested() version of every function we want to apply to the parse tables, in particular the rules in R/rules.R</li>
<li><p>We go through the whole structure only as many times as we call the visitor (instead of every *_nested() function going through it once), which is more efficient in terms of speed.</p></li>
</ul>
<p><code>create_filler()</code> was adapted to also initialize indention and lag_newlines.</p>
<pre><code>create_filler

## function(pd_flat) {
## 
##   pd_flat$line3 &lt;- lead(pd_flat$line1, default = tail(pd_flat$line2, 1))
##   pd_flat$col3 &lt;- lead(pd_flat$col1, default = tail(pd_flat$col2, 1) + 1L)
##   pd_flat$newlines &lt;- pd_flat$line3 - pd_flat$line2
##   pd_flat$lag_newlines &lt;- lag(pd_flat$newlines, default = 0L)
##   pd_flat$col2_nl &lt;- if_else(pd_flat$newlines &gt; 0L, 0L, pd_flat$col2)
##   pd_flat$spaces &lt;- pd_flat$col3 - pd_flat$col2_nl - 1L
##   pd_flat$multi_line &lt;- ifelse(pd_flat$terminal, FALSE, NA)
##   pd_flat$indention_ref_id &lt;- NA
##   ret &lt;- pd_flat[, !(names(pd_flat) %in% c("line3", "col3", "col2_nl"))]
## 
## 
##   if (!("indent" %in% names(ret))) {
##     ret$indent &lt;- 0
##   }
## 
##   if (any(ret$spaces &lt; 0L)) {
##     stop("Invalid parse data")
##   }
## 
##   ret
## }
## &lt;environment: namespace:styler&gt;

code &lt;- "a &lt;- function(x) { if(x &gt; 1) { 1+1 } else {x} }"
pd_nested &lt;- compute_parse_data_nested(code)
pd_nested_enhanced &lt;- pre_visit(pd_nested, c(create_filler))
pd_nested_enhanced

## # A tibble: 1 x 20
##   line1  col1 line2  col2    id parent token terminal  text short
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;chr&gt;    &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1     1     1    47    49      0  expr    FALSE            
## # ... with 10 more variables: token_before &lt;chr&gt;, token_after &lt;chr&gt;,
## #   internal &lt;lgl&gt;, child &lt;list&gt;, newlines &lt;int&gt;, lag_newlines &lt;int&gt;,
## #   spaces &lt;int&gt;, multi_line &lt;lgl&gt;, indention_ref_id &lt;lgl&gt;, indent &lt;dbl&gt;</code></pre>
<p>As a next step, we need to find a way to serialize the nested tibble, or in other words, to transform it to its character vector representation. As a starting point, consider the function <code>serialize</code> that was introduced in the vignette “Data Structures”.</p>
<pre><code>serialize &lt;- function(x) {
  out &lt;- Map(
    function(terminal, text, child) {
      if (terminal)
        text
      else
        serialize(child)
    },
    x$terminal, x$text, x$child
  )
  out
}

serialize(pd_nested) %&gt;% unlist

##  [1] "a"        "&lt;-"       "function" "("        "x"        ")"       
##  [7] "{"        "if"       "("        "x"        "&gt;"        "1"       
## [13] ")"        "{"        "1"        "+"        "1"        "}"       
## [19] "else"     "{"        "x"        "}"        "}"</code></pre>
<p><code>serialize</code> can be combined with <code>serialize_parse_data_flat</code>. The latter pastes together the column “text” of a flat parse table by taking into account space and line break information, splits the string by line break and returns it.</p>
<pre><code>serialize_parse_data_flat

## function(pd_flat) {
##   pd_flat %&gt;%
##     summarize_(
##       text_ws = ~paste0(
##         text, newlines_and_spaces(newlines, spaces),
##         collapse = "")) %&gt;%
##     .[["text_ws"]] %&gt;%
##     strsplit("\n", fixed = TRUE) %&gt;%
##     .[[1L]]
## }
## &lt;environment: namespace:styler&gt;</code></pre>
<p>However, things get a bit more complicated, mainly because line break and white space information is not only contained in the terminal tibbles of the nested parse data, but even before, as the following example shows.</p>
<pre><code>pd_nested_enhanced$child[[1]]

## # A tibble: 3 x 20
##   line1  col1 line2  col2    id parent       token terminal  text short
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;       &lt;chr&gt;    &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1     1     1     1     3     49        expr    FALSE            
## 2     1     3     1     4     2     49 LEFT_ASSIGN     TRUE    &lt;-    &lt;-
## 3     1     6     1    47    48     49        expr    FALSE            
## # ... with 10 more variables: token_before &lt;chr&gt;, token_after &lt;chr&gt;,
## #   internal &lt;lgl&gt;, child &lt;list&gt;, newlines &lt;int&gt;, lag_newlines &lt;int&gt;,
## #   spaces &lt;int&gt;, multi_line &lt;lgl&gt;, indention_ref_id &lt;lgl&gt;, indent &lt;dbl&gt;

pd_nested_enhanced$child[[1]]$child[[1]]

## # A tibble: 1 x 20
##   line1  col1 line2  col2    id parent  token terminal  text short
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;  &lt;chr&gt;    &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1     1     1     1     1      3 SYMBOL     TRUE     a     a
## # ... with 10 more variables: token_before &lt;chr&gt;, token_after &lt;chr&gt;,
## #   child &lt;list&gt;, internal &lt;lgl&gt;, newlines &lt;int&gt;, lag_newlines &lt;int&gt;,
## #   spaces &lt;int&gt;, multi_line &lt;lgl&gt;, indention_ref_id &lt;lgl&gt;, indent &lt;dbl&gt;</code></pre>
<p>After “a” in <code>code</code>, there is a space, but this information is not contained in the tibble where we find the terminal “a”. In general, we must add newlines and spaces values <em>after</em> we computed character vector representation of the expression. In our example: we know that there is a space after the non-terminal “a” by looking at <code>pd_nested_enhanced$child[[1]]</code>. Therefore, we need to add this space to the very last terminal within <code>pd_nested_enhanced$child[[1]]</code> before we collapse everything together.</p>
<pre><code>serialize_parse_data_nested_helper

## function(pd_nested, pass_indent) {
##   out &lt;- pmap(list(pd_nested$terminal, pd_nested$text, pd_nested$child,
##                    pd_nested$spaces, pd_nested$lag_newlines, pd_nested$indent),
##               function(terminal, text, child, spaces, lag_newlines, indent) {
##                 total_indent &lt;- pass_indent + indent
##                 preceding_linebreak &lt;- if_else(lag_newlines &gt; 0, 1, 0)
##                 if (terminal) {
##                   c(add_newlines(lag_newlines),
##                     add_spaces(total_indent * preceding_linebreak),
##                     text,
##                     add_spaces(spaces))
##                 } else {
##                   c(add_newlines(lag_newlines),
##                     add_spaces(total_indent * preceding_linebreak),
##                     serialize_parse_data_nested_helper(child, total_indent),
##                     add_spaces(spaces))
##                 }
##               }
##   )
##   out
## }
## &lt;environment: namespace:styler&gt;

serialize_parse_data_nested

## function(pd_nested) {
##   out &lt;- c(add_newlines(start_on_line(pd_nested) - 1),
##            serialize_parse_data_nested_helper(pd_nested, pass_indent = 0)) %&gt;%
##     unlist() %&gt;%
##     paste0(collapse = "") %&gt;%
##     strsplit("\n", fixed = TRUE) %&gt;%
##     .[[1L]] %&gt;%
##     trimws(which = "right")
##   out
## }
## &lt;environment: namespace:styler&gt;</code></pre>
<p>Before we are done, we need to add information regarding indention to the parse table. We can add indention after every line break that comes after a round bracket with <code>indent_round()</code>. And then serialize it.</p>
<pre><code><a href="../../reference/visit.html">pre_visit(pd_nested, 
               c(create_filler, 
                 purrr::partial(indent_round, indent_by = 2)))

## # A tibble: 1 x 20
##   line1  col1 line2  col2    id parent token terminal  text short
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;chr&gt;    &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1     1     1    47    49      0  expr    FALSE            
## # ... with 10 more variables: token_before &lt;chr&gt;, token_after &lt;chr&gt;,
## #   internal &lt;lgl&gt;, child &lt;list&gt;, newlines &lt;int&gt;, lag_newlines &lt;int&gt;,
## #   spaces &lt;int&gt;, multi_line &lt;lgl&gt;, indention_ref_id &lt;lgl&gt;, indent &lt;dbl&gt;</a></code></pre>
<p>We can see how indention works with a more complicated example</p>
<pre><code>indented &lt;- c(
  "call(", 
  "  1,", 
  "  call2(", 
  "    2, 3,", 
  "    call3(1, 2, 22),", 
  "    5", 
  "  ),", 
  "  144",
  ")"
)

not_indented &lt;- trimws(indented)
back_and_forth &lt;- not_indented %&gt;%
  compute_parse_data_nested() %&gt;%
  pre_visit(c(create_filler, 
        purrr::partial(indent_round, indent_by = 2))) %&gt;%
  serialize_parse_data_nested()

identical(indented, back_and_forth)

## [1] TRUE</code></pre>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p>Developed by <a href="http://krlmlr.info">Kirill Müller</a>, <a href="http://lorenzwalthert.netlify.com">Lorenz Walthert</a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.4.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
